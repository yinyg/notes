## JVM整体结构及内存模型

![JVM整体结构及内存模型](./images/JVM整体结构及内存模型.png)



## JVM内存参数设置

#### 堆

- **-Xms2048m**: 设置JVM初始堆内存，建议与-Xmx相同，避免每次垃圾回收完成后JVM重新分配内存；
- **-Xmx2048m**: 设置最大堆内存；
- **-Xmn1024m**: 设置年轻代内存。

#### 栈（线程栈）

- **-Xss512k**: 设置线程的栈大小。在相容的物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000-5000个。

#### 方法区（元空间）

方法区是JVM规范，所有虚拟机必须遵守。永久代（PermGen space，<=jdk7）、元空间（Metaspace，>=jdk8）是HotSpot对方法区的实现。

- **-XX:MaxMetaspaceSize=256m**: 设置元空间最大内存，默认-1，即不限制，或者说只受限于本地内存大小；
- **-XX:MetaspaceSize=256m**: 设置元空间触发full GC的初始阈值，默认为21m，达到该值就会触发full GC进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当减低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，释放提高该值；
- **-XX:PermSize=256m**: 设置永久代初始内存。

由于调整元空间的大小需要full GC，这是非常昂贵的操作，如果应用在启动的时候就发生大量的full GC，通常是由于元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般将这两个值都设置成256m。



## 对象的创建

#### 1、类加载检查

当new一个对象、对象克隆、对象反序列化时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个类是否已被加载（加载、验证、准备、解析、初始化）过。如果没有，那必须先加载该类。

#### 2、分配内存

对象所需内存的大小在内加载完成后变可完全确定，为对象分配内存空间，等同于把一块确定大小的内存从JVM堆中划分出来。

**划分内存的方法**：

- **指针碰撞**：如果JVM堆中内存是绝对规整的，所有用的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离；
- **空闲列表**：如果JVM堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

**解决并发问题的方法**：

- **CAS(compare and swap)**: 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理；
- **本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）**: 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在JVM堆中预先分配一小块内存，通过-XX:+/-UseTLAB参数来设定虚拟机是否使用TLAB(JVM默认会开启-XX:+UseTLAB), -XXTLAPSize指定TLAB大小。 

#### 3、初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作也可以提前至TLAB分配时进行。这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接只用，程序能访问到这些字段的数据类型所对应的零值。

