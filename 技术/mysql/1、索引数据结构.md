## 索引

索引是一种 **数据结构**。数据库索引是 DBMS 中一个 **排序的数据结构**，以 **协助快速查询、更新** 数据库表中数据。索引的实现通常使用 B 树以及变种 B+ 树。



## 索引数据结构

- 二叉树
- 红黑树
- Hash表
- B-Tree

不使用二叉树存储索引：树的高度决定查找效率，不同的插入顺序会导致树的高度不一样，而树的高度直接影响了树的查找效率，不平衡的二叉查找树自然查找效率更低，严重时可能退化成链表。

不使用红黑树存储索引：红黑树虽然查找效率很高，但是一般情况下，数据库存储的数据量非常庞大，树的高度会特别高，且如果树的节点过多的话，平衡树的过程，在节点之间转移会花费较多的时间。如果要查找的数据正好在树的叶子节点，那查找会非常慢。

Hash 索引和 B+ 树索引有以下几点显见的区别：(来源：力扣(LeetCode)https://leetcode-cn.com/leetbook/read/database-handbook/pxd53i/)

- Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；
- Hash 索引不支持使用索引进行排序；
- Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；
- Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；
- Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。

**B-Tree**

- 叶节点具有相同的深度，叶节点的指针为空
- 所有索引元素不重复
- 节点中的索引数据从左到右递增排列

**B+Tree(B-Tree变种)**

- 非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引
- 叶子节点包含所有索引字段

**Hash**

对索引的key进行一次hash计算就可以定位除数据存储的位置

- 很多时候Hash索引要比B+树索引更高效
- 仅能满足"="、"IN"，不支持范围查询
- hash冲突问题



## MyISAM存储引擎和InnoDB存储引擎一级索引实现

- MyISAM存储引擎索引文件和数据文件是分离的(非聚集)；
- InnoDB存储引擎索引是聚集索引，表数据文件本身就是按B+Tree组织的一个索引结构文件。

聚集索引：叶节点包含了完整的数据记录，MyISAM存储引擎主键索引的叶子节点存储的是数据的地址，InnoDB存储引擎主键索引的叶子节点存储的是完整的数据记录。

![MyISAM存储引擎一级索引.png](./images/MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95.png)

![InnoDB存储引擎一级索引.png](./images/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95.png)

![InnoDB存储引擎二级索引.png](./images/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png)

![InnoDB存储引擎联合索引.png](./images/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png)

**为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？**

如果设置了逐渐，InnoDB会选择主键组织聚集索引，如果没有建主键，InnoDB会选择一个不包含null值的唯一索引组织聚集索引，如果没有这样的唯一索引，InnoDB会用一个递增的rowid组织聚集索引。

使用整型的自增主键，可以防止页分裂，如果使用随机主键，往已经写满数据的页中插入数据，会使该页分裂成2个新的页。

**为什么非主键索引结构叶子节点存储的是主键值？**

- 一致性

​		一张表只有一个聚集索引或一级索引，其他的都是二级索引，当需要更新数据时，只需要更新聚集索引，二级索引存储的是主键值，则无需更新二级索引，同时也避免了聚集索引和二级索引数据不一致的问题，以及为了保证聚集索引和二级索引数据一致带来的额外开销。

- 节省存储空间

