1、请你说说Java的特点和优点，为什么要选择Java？

1. Java在吸收了C++语言的各种优点的同事去除了C++语言中令人难以理解的多继承、指针等概念，在保证了强大的功能性的基础上，还比C++更为简单易用；
2. Java语言很好的实现了面向对象理论，保证了程序员可以用优雅的思维方式进行复杂的编程；
3. Java拥有跨平台特性（依赖于不同平台的JVM，将编译后的字节码解释程特定平台的机器码）；
4. Java提供了很多内置的类库；
5. Java提供了垃圾收集器，将开发人员从对内存的管理中解脱出来；
6. Java拥有良好的安全性和健壮性（沙箱安全机制和数组边界检查、强类型机制、垃圾收集器、异常处理等）；
7. Java提供了对Web应用程序的支持（Applet、Servlet、JSP）。



2、请你说说Java的基本类型和引用类型？（关注内存空间、范围）

基本类型：byte、short、int、long、float、double、boolean、char；

引用类型：数组、类、接口；

null。



3、请你说一下接口和抽象类的区别？

相同点：

1. 接口和抽象类都不能被实例化；
2. 接口和抽象类都可以定义抽象方法，实现接口或集成抽象类的普通类必须实现这些抽象方法。

不同点：

1. 接口只能定义抽象方法和默认方法，不能为普通方法提供方法实现，抽象类既可以定义抽象方法，又可以为普通方法提供实现；
2. 接口只能定义静态常量，抽象类既可以定义静态常量，又可以定义普通成员变量；
3. 接口不能提供构造方法，抽象方法可以提供构造方法用于完成属于抽象类的初始化；
4. 接口不能包含初始化块，抽象方法可以包含初始化块。



4、请你说一下final关键字？

1. final修饰类时，该类不能被继承；
2. final修饰方法时，该方法不能被重写；
3. final修饰变量时，该变量不能被重新赋值。



5、说说static修饰符的用法？

1. static可以修饰类的方法、变量、代码块、内部类，被static修饰后，它们变成类的成员，也叫静态成员；
2. static修饰的类成员，和类同时被加载，先于对象存在；
3. static修饰的类方法中不能用this，因为类先于对象存在，而this伴随着对象存在。



6、String类能否被继承，说说字符串直接量和new String()的区别？

1. String类被final修饰，因此String类不能被继承；
2. 使用字符串直接量时，JVM会使用常量池来管理，而使用new String()时，则将对象存储对堆内存中；
3. 使用new String()时会多创建一个对象，所以建议使用字符串直接量的方式来创建字符串。



7、String、StringBuilder、StringBuffer有什么区别？

1. String对象是不可变的，一旦创建，就不可以被修改；
2. StringBuilder、StringBuffer可以用来封装字符串，并提供了一系列的API来操作字符串，并且提供了toString()方法来创建一个String对象；
3. StringBuilder、StringBuffer有共同的父类AbstaractStringBuilder，二者无论是构造方法还是普通方法都基本相同，不同的一点是，StringBuilder不是线程安全 的，StringBuffer是线程安全的。



8、请你说说==和equals()的区别？

1. ==用来比较基本类型变量时，比较的是左右两边的值；
2. ==用来比较引用类型变量时，比较的是左右两边的内存地址；
3. equals()是Object类提供的方法，所有引用类型的变量都可以调用equals()方法，但是Object类提供的equals()方法和==一致，可以通过重写queals()方法来满足需求。



9、请你说说hashCode()和equals()的区别，为什么重写equals()就要重写hashCode()？

1. hashCode()用来获取hash值；
2. equals()用来比较两个对象是否相等；
3. hashCode()和equals()有一个约定，两个相等的对象，他们的hash值一定相同，两个hash值相同的对象不一定相等，所以为了满足这个约定，重写equals()时就要重写hashCode()。



10、请你讲一下Java8的新特性？

- 函数是接口；
- Lambda表达式；
- 方法引用/构造方法引用；
- Stream API；
- 接口默认方法；
- ......



11、介绍一下包装类的自动拆箱与自动装箱？

**自动装箱：**把基本类型的的数据赋值给对应的包装类对象时（包含方法入参），自动将基本类型的数据转为包装对象；

**自动拆箱：**把包装类对象赋值给对应的基本类型时（包含方法入参），自动将包装类对象转换为基本类型的数据。



12、请你说说Java的异常处理机制？

**异常处理：**try、catch、finally；

**抛出异常：**throws用在方法上来声明可能抛出异常，throw用在方法体来抛出异常；

异常堆栈信息：如果没有处理异常，将异常抛给JVM来处理，JVM将会打印异常的堆栈信息。



13、说说你对面向对象的理解？

**封装：**隐藏对象的细节，对外提供访问对象的方法；

**继承：**子类继承父类，则子类拥有父类的属性和方法，子类可以父类进行方法重写和扩展。缺点是侵入性（子类必须拥有父类的属性和方法）、耦合性（修改父类的属性和方法时，需要考虑子类的修改）；

**多态：**多个类继承或实现同一个父类或接口，父类或接口的引用指向子类对象。



14、请你说说重载和重写的区别，构造方法能不能重写？

**重载：**在同一个类或子类中，提供方法名相同，参数不同（参数类型、参数数量）的方法，叫方法重载；

**重写：**子类继承父类时，在子类中提供方法名相同，参数相同、返回值类型相同的方法，叫方法重写；

**构造方法：**构造方法的方法名和类名相同，且没有返回值，所以构造方法不存在重写。



15、请介绍一下访问修饰符？

访问级别从小到大：private -> default -> protected -> public

**private:** 只有当前类的内部可以访问；

**default:** 当前类内部、同一个包下的类可以访问；

**protected:** 当前类内部、同一个包下的类、其它包下的子类可以访问；

**public:** 所有类可以访问。



<font color="red">16、请你说说泛型、泛型擦除？</font>

泛型：利用泛型可以告诉编译器接受哪些对象类型，编译器会自动帮你转换接收的对象，并检查插入的类型是否允许；

泛型擦除：泛型只存在于编译阶段，JVM并不知道泛型的存在，运行过程中，可以接收其他类型的对象。



<font color="red">17、请说说你对反射的了解？</font>

1. 程序运行时，可以通过反射获取任意一个类的Class对象，并通过这个对象查看这个类的信息；
2. 程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；
3. 程序运行时，可以通过反射生成一个类的动态代理类或动态代理对象。

**应用：**加载数据库驱动程序、根据XML配置生成对应类的实例、AOP。



18、请你说说多线程？

- 线程是操作系统的最小调度单元；
- 一个进程可以创建多个线程，这些线程都拥有各自的计数器、堆栈、局部变量，并且能够共享进程内的资源，处理器可以在这些线程之间快速切换，从而让使用者感觉这些此案城在同时执行；
- 优点：更多的利用CPU核心、更快的相应时间。



19、说说线程的创建方式？

继承Thread类；

实现Runable接口（没有返回值）；

实现Callable接口（有返回值）。



20、说说线程的状态？

- 初始状态NEW；
- 可运行状态RUNNABLE；
- 阻塞状态BLOCKED；
- 等待状态WAITING；
- 超时等待状态TIME_WAITING；
- 终止状态TERMINATED。



21、说说wait()和sleep()的区别？

- wait()是Object提供的实例方法，sleep()是Thread提供的静态方法；
- wait()依赖于synchronized，使得程序进入WAIT状态，wait()也可以带时间参数，使得程序进入TIMED_WAITING状态，sleep()使得程序进入TIMED_WAITING状态；
- wait()需要由notify()/notifyAll()唤醒，带时间参数的wait()，在时间范围内没有被唤醒，也将自动返回RUNNABLE状态，sleep()在设置的时间后自动返回RUNNABLE状态。



<font color="red">22、说说怎么保证线程安全？</font>

1. 多个线程访问同一个共享变量，可能会出现异常情况；
2. 使用原子类，可以使对共享变量的操作是一个原子操作；
3. 使用volatile关键字修饰共享变量，可以保证线程对共享变量的操作对其他线程可见；
4. 使用锁，可以使同一时刻只有一个线程访问共享变量。



<font color="red">23、说说你了解的线程同步的方式？</font>

synchronized、Lock。



24、说说你了解的线程通信方式？

Monitor(synchronized)、Condition(Lock)。

