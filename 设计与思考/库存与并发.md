# 库存与并发

本文档关注的是一般场景和秒杀场景下，库存扣减问题，限流、防止重复提单等不在本文档的关注范围。

## 设计方案

### 方案1: 数据库

对一条库存数据进行更新，数据库本身的X锁能保证同一时间只有一个事务对记录进行更新。

<font style="font-size:18px">**具体流程如下**</font>:

1. 查询数据库，找出符合条件的库存记录；

2. 对比剩余库存是否满足本次提单数量，如果不满足，直接提示库存不足，提单失败；

3. 进行库存扣减，注意这里必须添加"num >= 提单数量"的条件，防止库存被其他线程扣减，从而导致负卖，语句如下:

   ```mysql
   update t_stock set num = num - ${提单数量} where id = ${id} and num >= ${提单数量};
   ```

4. 如果上一步中update语句返回影响的行数 > 0，则提单成功，否则提单失败。

### 方案2: 数据库+分布式锁

方案1中，如果瞬时有过多的请求落在数据库上，可能使得数据库挂起，这里使用分布式锁对方案1作出优化。

<font style="font-size:18px">**具体流程如下**</font>:

1. 查询数据库，找出符合条件的库存记录；

2. 对比剩余库存是否满足本次提单数量，如果不满足，直接提示库存不足，提单失败；

3. **以库存记录id为key，获取分布式锁**；

4. 进行库存扣减，这里同样必须添加"num >= 提单数量"的条件，语句如下:

   ```mysql
   update t_stock set num = num - ${提单数量} where id = ${id} and num >= ${提单数量};
   ```

5. 如果上一步中update语句返回影响的行数 > 0，则提单成功，否则提示库存不足，提单失败；

6. **释放分布式锁**。

### 方案3: 数据库+Redis+消息队列+job

方案2无法满足秒杀场景下的并发性能，针对秒杀场景的需求，便有了方案3的设计。

将秒杀活动的商品提前缓存到Redis中，通过Redis的原子性操作完成库存扣减，并能够防止超卖。同时使用异步消息，完成对数据库的更新，这里还需要使用job来校验数据库和Redis的数据一致性。

<font style="font-size:18px">**具体流程如下**</font>:

1. 提前维护好秒杀活动商品，并将秒杀活动商品的库存缓存到Redis；

2. 从Redis中查询出秒杀商品的库存，如果缓存不存在，或则库存不满足本地提单数量，直接提示库存不足，提单失败；

3. 进行库存扣减，这里同样需要对库存进行再次校验，使用lua脚本来保证库存校验+扣减的原子性操作，lua脚本的参考如下:

   ```lua
   if ((redis.call('exists', KEYS[1]) == 1) and (tonumber(redis.call('get', KEYS[1])) >= tonumber(ARGV[1]))) then
     redis.call('decrby', KEYS[1], ARGV[1]);
     return 1;
   end;
   return 0;
   ```

4. 如果上一步返回1，则提单成功，否则提示库存不足，提单失败；

5. 如果提单成功，发送异步消息，更新数据库。



## 总结优化

上述3种方案，一般场景选择方案2，秒杀场景选择方案3。

如果需要进一步提升并发性能，可以对库存进行拆分，比如将库存按照区域进行维护，也可以对同一库存记录进行拆分，拆分为多个库存记录。这样，方案2中，可以结合一定的算法，同时利用多把锁。

可以进行进一步的设计，支持"一单多商品"的提单。

