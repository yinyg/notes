共享锁、排他锁（兼容性）

意向锁（意向共享锁IS、意向排他锁）（兼容性）



show engine innode status

information_schema.innodb_trx

information_schema.innodb_locks

information_schema.innodb_lock_waits



一致性非锁定读、MVCC（RC、RR隔离级别差异）、一致性锁定读



自增长与锁

select max(auto_inc_col) from t for update;(auto_inc_col列不存在)

insert-like、sample inserts、bulk inserts、mixed mode inserts

show variables like "innodb_autoinc_lock_mode";

基于语句的复制(statement-base replication)、基于行的复制(row-base replication)



外键和锁

insert或update时，需要查询父表记录，这里使用的不是一致性非锁定读，而是会对父表记录加上S锁



lock tables table_name/unlock tables会提交当前会话活跃的事务











# InnoDB Locking

## Shared and Exclusive Locks(共享锁与排它锁)

**共享锁(S)**是指不同的事务可以同时持有同一对象的共享锁。

**排它锁(X)**是指不同的事务不可以同时持有同一对象的锁，这里又分为2中情况：

- 当事务1已经持有对象A的排它锁，事务2想要获得对象A的共享锁或排它锁，事务2将被阻塞，直到事务1释放了对象A的排它锁。
- 当事务1已经持有对象A的共享锁，事务2想要获得对象A的排它锁，事务2将被阻塞，直到事务1释放了对象A的排它锁，但是如果事务2想要获得对象A的共享锁，事务2将会立即获得对象A的共享锁。



## Intention Locks(意向锁)

意向锁表示一种意图，分为**意向共享锁(IS)**、**意向排它锁(IX)**。

获取某一行记录的共享锁时，首先会获得该表的意向共享锁；获取某一行记录的排它锁时，首先会获得该表的意向排它锁。

意向锁不会阻塞除全表操作以外的任何操作，这里的全表操作指lock tables table_name read/write。

意向锁(IS、IX)与表锁(S、X)的兼容性如下:

|        | **X** | **IX** | **S** | **IS** |
| ------ | ----- | ------ | ----- | ------ |
| **X**  | 冲突  | 冲突   | 冲突  | 冲突   |
| **IX** | 冲突  | 兼容   | 冲突  | 兼容   |
| **S**  | 冲突  | 冲突   | 兼容  | 兼容   |
| **IS** | 冲突  | 兼容   | 兼容  | 兼容   |

从show engine innodb status可以看到如下的日志:

```mysql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```



## Record Locks(记录锁)

记录锁锁定的是一条索引记录，可以是共享锁，也是可以是排它锁。

从show engine innodb status可以看到如下的日志，关键点是**locks rec but not gap**，表示锁定的是一条记录而不是间隙。

```mysql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
0: len 4; hex 8000000a; asc     ;;
1: len 6; hex 00000000274f; asc     'O;;
2: len 7; hex b60000019d0110; asc        ;;
```



## Gap Locks(间隙锁)

当对一条索引记录加上记录锁时，同时也会对其前后间隙加上间隙锁。如果当前记录不存在，也会对所属区间加上间隙锁。

间隙锁阻止其它事务在区间内插入新的数据，区间遵循左闭右开。

当使用唯一索引的全部字段检索数据时，这里不使用间隙锁，仅仅使用记录锁。

It is also worth noting here that conflicting locks can be held on a gap by different transactions. For example, transaction A can hold a shared gap lock (gap S-lock) on a gap while transaction B holds an exclusive gap lock (gap X-lock) on the same gap. The reason conflicting gap locks are allowed is that if a record is purged from an index, the gap locks held on the record by different transactions must be merged.

### 下面是一个间隙锁的demo

表t_gap_lock_demo已经存在3、5、8、10这些记录，当对记录8加上记录锁时，同时也会对[5, 8)、(8, 10)这两个区间加上间隙锁。

表结构与数据:

```mysql
drop tables if exists `t_gap_lock_demo`;
create table `t_gap_lock_demo`(
	`id` bigint not null primary key auto_increment,
	`code` bigint not null,
	index `idx_code`(`code`)
);
insert into `t_gap_lock_demo`(`code`) values(3);
insert into `t_gap_lock_demo`(`code`) values(5);
insert into `t_gap_lock_demo`(`code`) values(8);
insert into `t_gap_lock_demo`(`code`) values(10);
```

说明: 当前索引3、5、8、10；事务1锁定索引记录8，则区间[5, 8)、(8, 10)也会被加上间隙锁；事务2如果要在此区间执行insert操作，会被阻塞，而delete、update操作不会受影响。

| Transaction 1                                                | Transaction 2                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| begin;                                                       | begin;                                                       |
| select * from `t_gap_lock_demo` where `code` = 8 lock in share mode; |                                                              |
|                                                              | insert into `t_gap_lock_demo`(`code`) values(5); -- 阻塞(间隙锁)<br/>insert into `t_gap_lock_demo`(`code`) values(7); -- 阻塞(间隙锁)<br/>insert into `t_gap_lock_demo`(`code`) values(8); -- 阻塞(记录锁)<br/>insert into `t_gap_lock_demo`(`code`) values(9); -- 阻塞(间隙锁)<br/>insert into `t_gap_lock_demo`(`code`) values(10); -- 不阻塞<br/><br/>select * from `t_gap_lock_demo` where `code` = 7 for update; -- 不阻塞<br/>select * from `t_gap_lock_demo` where `code` = 8 for update; -- 阻塞(记录锁)<br/><br/>delete from `t_gap_lock_demo` where `code` = 7; -- 不阻塞<br/>delete from `t_gap_lock_demo` where `code` = 8; -- 阻塞(记录锁) |
| commit;                                                      | commit;                                                      |

可以通过下面的语句查看事务与锁信息:

```mysql
select * from information_schema.INNODB_TRX;
select * from information_schema.INNODB_LOCKS;
select * from information_schema.INNODB_LOCK_WAITS;
show engine innodb status;
```



## Next-Key Locks(临键锁)

临键锁就是记录锁+间隙锁。



## Insert Intention Locks(插入意向锁)

If a duplicate-key error occurs, a shared lock on the duplicate index record is set.

### 下面是一个插入意向锁的demo

表结构与数据：

```mysql
drop tables if exists `t_insert_intention_lock_demo`;
create table `t_insert_intention_lock_demo`(
	`id` bigint not null primary key auto_increment,
	`code` bigint not null,
	index `idx_code`(`code`)
);
insert into `t_insert_intention_lock_demo`(`code`) values(3);
insert into `t_insert_intention_lock_demo`(`code`) values(5);
insert into `t_insert_intention_lock_demo`(`code`) values(8);
insert into `t_insert_intention_lock_demo`(`code`) values(10);
```



```mysql
-- demo1: 非唯一索引: 插入相同的索引，不会阻塞
-- 数据准备
drop tables if exists `t_insert_intention_lock_demo`;
create table `t_insert_intention_lock_demo`(
	`id` bigint not null primary key auto_increment,
	`code` bigint not null,
	index `idx_code`(`code`)
);
insert into `t_insert_intention_lock_demo`(`code`) values(3);
insert into `t_insert_intention_lock_demo`(`code`) values(5);
insert into `t_insert_intention_lock_demo`(`code`) values(8);
insert into `t_insert_intention_lock_demo`(`code`) values(10);
-- 数据准备


-- 查询事务和锁信息
select * from information_schema.INNODB_TRX;
select * from information_schema.INNODB_LOCKS;
select * from information_schema.INNODB_LOCK_WAITS;
show engine innodb status;
-- 查询事务和锁信息


-- 非唯一索引: 插入相同的索引，不会阻塞
-- Transaction 1
begin;

insert into `t_insert_intention_lock_demo`(`code`) values(6);

commit;
-- Transaction 1


-- Transaction 2
begin;

insert into `t_insert_intention_lock_demo`(`code`) values(5);
insert into `t_insert_intention_lock_demo`(`code`) values(6);
insert into `t_insert_intention_lock_demo`(`code`) values(7);

commit;
-- Transaction 2
-- demo1: 非唯一索引: 插入相同的索引，不会阻塞




-- demo2: 唯一索引: 插入相同的索引会阻塞
-- 数据准备
drop tables if exists `t_insert_intention_lock_demo`;
create table `t_insert_intention_lock_demo`(
	`id` bigint not null primary key auto_increment,
	`code` bigint not null,
	unique index `uniq_code`(`code`)
);
insert into `t_insert_intention_lock_demo`(`code`) values(3);
insert into `t_insert_intention_lock_demo`(`code`) values(5);
insert into `t_insert_intention_lock_demo`(`code`) values(8);
insert into `t_insert_intention_lock_demo`(`code`) values(10);
-- 数据准备


-- 查询事务和锁信息
select * from information_schema.INNODB_TRX;
select * from information_schema.INNODB_LOCKS;
select * from information_schema.INNODB_LOCK_WAITS;
show engine innodb status;
-- 查询事务和锁信息


-- 唯一索引: 插入相同的索引会阻塞
-- Transaction 1
begin;

insert into `t_insert_intention_lock_demo`(`code`) values(6);

commit;
-- Transaction 1


-- Transaction 2
begin;

insert into `t_insert_intention_lock_demo`(`code`) values(5);
insert into `t_insert_intention_lock_demo`(`code`) values(6);
insert into `t_insert_intention_lock_demo`(`code`) values(7);

commit;
-- Transaction 2
-- demo2: 唯一索引: 插入相同的索引会阻塞
```

